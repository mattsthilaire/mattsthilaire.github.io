{
  "hash": "7e1b311cd82b0fe3e26b75ed7fef0d02",
  "result": {
    "markdown": "---\ntitle: Better OOP Learning Through Chemistry\nexecute:\n  error: true\nauthor: Matt St. Hilaire\ndate: 07/30/2023\nformat:\n  html:\n    code-fold: false\n---\n\nThere are literally <a href=\"https://realpython.com/python3-object-oriented-programming\"/>100's</a> upon <a href=\"https://www.youtube.com/watch?v=Ej_02ICOIgs\"/>100's</a>  upon <a href=\"https://kinsta.com/blog/python-object-oriented-programming/\"/>100's</a> of Object Orientation Programming blog Posts, tutorials, or wiki pages. So why add more? Well...really there's no strictly legitimate reason. Those other ones are great. However, I had this idea and wanted to see how well I knew OOP and if someone out there vibes on my wavelength, maybe this will make more sense than those other ones.\n\nSo, what the use case? A bit of chemistry. I have a physics background myself, however, most people that probably navigated here took at least a course or two of chem in high school and or college, having remember reactions, atomic numbers, and orbitals.\n\nWe'll flesh out our OOP skills and take a look at some stuff in python by making an OOP framework for chemistry i.e. atoms, protons, electrons, neutrons, elements, etcs.\n\nPlease be warned, I'm not a chemist and any feedback on accuracy will be more than welcomed.\n\nSo with that, let's dive in.\n\n## In the Beginning....\n\nIn order to build up our chem universe, we're going to need some elementry particles. We could get fancy and do <a href=\"https://en.wikipedia.org/wiki/Quark\">quarks</a> for <a href=\"https://en.wikipedia.org/wiki/Proton\">protons</a> and <a href=\"https://en.wikipedia.org/wiki/Neutron\">neutrons</a>, but let's keep it simple with <a href=\"https://en.wikipedia.org/wiki/Electron\">electrons</a>, protons, and neutrons as our building blocks.\n\nFor those, we're starting off building a <a href=\"https://en.wikipedia.org/wiki/Class_(computer_programming)\">class</a> in python to represent these:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nclass Electron:\n    charge = -1\n    mass = 9.10938356e-31\n\n\nclass Proton:\n    charge = 1\n    mass = 1.67262158e-27\n\n\nclass Neutron:\n    charge = 0\n    mass = 1.67492721e-27\n```\n:::\n\n\nThis is almost as simple as classes get in python. A class is an object that can store values and do stuff. More on the doing stuff later. Here, our classes are only storing stuff i.e. charge and mass as integers and floating point numbers, repsepctively. They can literally store anything we want: lists, dicts, strings, other classes. We could have added components to proton to simulate quarks (in violation of what I set as a preliminary earlier) and definted it as this:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nclass ProtonWithQuarks:\n    charge = 1\n    mass = 1.67262158e-27\n    components = [\"upquark\", \"upquark\", \"downquark\"]\n\n```\n:::\n\n\nWe could have even defined a quark class and put a quark in a list for our ProtonWithQuark class. Classes can have any <a href=\"https://en.wikipedia.org/wiki/Attribute_(computing)\">attribute</a> we want them to have. Our restrictions are only our imagination and available memory.\n\nAttributes are data that a class holds. In our case for our elementary particle classes, we have charge and mass. We could have other things like mentioned above, but these two suit our needs for now. To access these attributes, we first have to define instances of our particle classes like so:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nelectron = Electron()\nproton = Proton()\nneutron = Neutron()\n```\n:::\n\n\nAfter creataing these variables, we can now use them to access our data in the class. Each time we call a class like this where we call the class name followed by (), we're creating a new instance of that class. In our case, we're creating a new instance and then assigning that instance to a variable that we can do stuff to.\n\nTo start doing stuff, let's grab some attributes from our class using the . operator. That's just your normal everyday period, or as the British call it, <a href=\"https://en.wikipedia.org/wiki/Full_stop\">full stop</a> symbol. To do so, we hit up our variable followed by a . and then the attribute we want to access.\n\n::: {.cell outputId='4fe36d3c-8381-4149-a381-89a2ff7d8976' execution_count=4}\n``` {.python .cell-code}\nelectron.charge, electron.mass\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n(-1, 9.10938356e-31)\n```\n:::\n:::\n\n\nNice. By using the . on our instance of electron, we can get the charge and mass: things we defined in the electron definition. We could do this through the proton and neutron instances as well:\n\n::: {.cell outputId='d573d48c-0c73-4972-e05f-ac8213680af6' execution_count=5}\n``` {.python .cell-code}\nprint(proton.charge, proton.mass)\nprint(neutron.charge, neutron.mass)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 1.67262158e-27\n0 1.67492721e-27\n```\n:::\n:::\n\n\nThese values get treated like any other in python i.e. if you grab the mass of an instance of an electron, you can add, multiple, divide, etc. That mass value is simply a float value stored in an Electron data type:\n\n::: {.cell outputId='7a52068b-6461-4b2f-e2d0-95da1364e2b1' execution_count=6}\n``` {.python .cell-code}\n# mass of 3 electrons\nelectron.mass * 3\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n2.732815068e-30\n```\n:::\n:::\n\n\nBut what happens if scientists discover a slight change in charge or mass of an electron. Or more realistically, what if you wanted to use different units. <a href=\"https://en.wikipedia.org/wiki/Coulomb\">Coulomb</a> instead of the <a href=\"https://en.wikipedia.org/wiki/Elementary_charge\">elementary charge</a>? Well, you might want to make your class more flexible by making your attributes more flexible when you call an instance of a class. That's were the `__init__` function comes in:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nclass Electron:\n\n    def __init__(self, charge=-1, mass=9.10938356e-31):\n        self.charge = charge\n        self.mass = mass\n\n\nclass Proton:\n\n    def __init__(self, charge=1, mass=1.67262158e-27):\n        self.charge = charge\n        self.mass = mass\n\n\nclass Neutron:\n\n    def __init__(self, charge=0, mass=1.67492721e-27):\n        self.charge = charge\n        self.mass = mass\n\n```\n:::\n\n\nThese definitions make things more flexible. Using the `__init__` in our class definitions means we can pass arguments to our class instances:\n\n::: {.cell outputId='29176cf5-7f60-4831-eac9-cceb93c9b37d' execution_count=8}\n``` {.python .cell-code}\nelectron = Electron(charge=2, mass=1)\nproton = Proton(charge=2, mass=20)\nneutron = Neutron(charge=0, mass=5)\n\nprint(electron.charge, proton.mass, neutron.charge)\n\n# passing no args uses our default args specified in our class definition\nelectron = Electron()\nprint(electron.charge, electron.mass)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2 20 0\n-1 9.10938356e-31\n```\n:::\n:::\n\n\nThis make our code more flexible and allow us to change values as needed. This also is our first view of a <a href=\"https://www.geeksforgeeks.org/dunder-magic-methods-python/\">dunder method</a>. Whenever you see a funtion in a class with __ surrounding it on each side (ex. `__myFunc__()`) then you know it's a dunder method.\n\nWe'll add more of these later, but these are special functions that allow our class to do things.\n\nBut before we get ahead of ourselves, let's talk about methods. The other important part of classes.\n\n## The Method\n\nA method is function that resides in a class. It can literally do anything and doesn't even have to be about that class. For example, we can add a function into our Electron class that just prints the word \"banana\":\n\n::: {.cell outputId='aa971667-7fe4-4683-d7c3-6c85edf457c9' execution_count=9}\n``` {.python .cell-code}\nclass Electron:\n\n    def __init__(self, charge=-1, mass=9.10938356e-31):\n        self.charge = charge\n        self.mass = mass\n\n    def print_banana(self):\n        print(\"banana\")\n\n\nelectron = Electron()\nelectron.print_banana()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbanana\n```\n:::\n:::\n\n\nWe simply made an instance of our electron class, use our . operator like before to access the function now (not an attribute), but then do our normal () at the end and make it a function call. Think about it like saying \"I want to call this function that's a part of my Electron object.\" It's like an attribute that's a function.\n\nNow normally, these functions actually do relate to the object in question. Seeing as people like to see stuff blown up, let' create a function called annihilate that used Einstein's famous $E = mc^2$ equation to get the energy released when an electron goes full mass 2 energy:\n\n::: {.cell outputId='9257db66-6d7e-493a-9f2e-6966691eaefd' execution_count=10}\n``` {.python .cell-code}\n# define speed of light\nc = 3 * 10**8\n\n\nclass Electron:\n\n    def __init__(self, charge=-1, mass=9.10938356e-31):\n        self.charge = charge\n        self.mass = mass\n\n    def annihilate(self):\n        return self.mass * c**2\n\n\nelectron = Electron()\nelectron.annihilate()\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n8.198445204e-14\n```\n:::\n:::\n\n\nSo what's going on with this annihilate method? Just like our print_banana method, we had to pass an argument called self? What does that mean? Self is the object itself...wait what?\n\nOk, it sounds weird but each method uses a specific argument called self which contains all the interesting information about the class it resides in. With self, you can call the class's attributes or other methods much like you would on instances of our class like we've seen before.\n\nIf you wanted to use the electrons mass like we did in annihilate, you'd pass the self variable as an argument, then you could use it by calling mass from the class itself i.e. self.mass. Think about it like trying to keep everything more organized. If you want to do something with an electron object, you're probably likely to use aspects or parts of the electron's attributes. In chem terms, the charge and mass of an electron usually take part in interactions, so if we need to call a function that does stuff with an electron, we're more than likely have to access these attributes. Self helps make this easy.\n\nWe could always supply arguments to our methods (just like a normal function), however, wouldn't it be annoying to have to pass the electron mass everytime we called annihilate and we didn't have that self method? Look at the (un)refactor below:\n\n::: {.cell outputId='e909dc71-3767-4d3e-8fed-83f8ee49d040' execution_count=11}\n``` {.python .cell-code}\nc = 3 * 10**8\n\n\nclass Electron:\n\n    def __init__(self, charge=-1, mass=9.10938356e-31):\n        self.charge = charge\n        self.mass = mass\n\n    def annihilate(self, mass):\n        return mass * c**2\n\n\nelectron = Electron()\nelectron.annihilate(electron.mass)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n8.198445204e-14\n```\n:::\n:::\n\n\nThis would make our code really ugly and force use to keep track of which class's attribute we're accessing. Self helps us contain all of this. If we're accessing a method on a specific class, might as well use it's attributes since we're there. In fact, I had to include self in the above example because python explicitly makes you use self as a method argument.\n\nThis does lead us though to highlight another good part of methods: just like normal functions we can pass them arguments. Let's try this with annihilate, but allow the variable c, speed of light, to be passed as an arg to the method:\n\n::: {.cell outputId='4670f9f9-1f93-48f4-cb36-80b9ae54c9e7' execution_count=12}\n``` {.python .cell-code}\nc = 3 * 10**8\n\n\nclass Electron:\n\n    def __init__(self, charge=-1, mass=9.10938356e-31):\n        self.charge = charge\n        self.mass = mass\n\n    def annihilate(self, c):\n        return self.mass * c**2\n\n\nelectron = Electron()\nelectron.annihilate(c)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n8.198445204e-14\n```\n:::\n:::\n\n\nAgain just like a normal function, we can pass arguments. Note however that we don't see self in the method call for `electron.annihilate(c)`. That's because the arguments we see after self are the only ones you have to pass to the function. Self is already baked in when you create the instance of that class. Everytime you call a method it has access to that self argument without you needing to call it.\n\nPython even errors out if you try to pass self as an arg when you are outside of the method. It will tell you that you passed too many args to that method:\n\n::: {.cell outputId='29ef093b-f2f1-4cf2-833b-28058001c014' execution_count=13}\n``` {.python .cell-code}\nelectron = Electron()\nelectron.annihilate(electron, c)\n```\n\n::: {.cell-output .cell-output-error}\n```\nTypeError: annihilate() takes 2 positional arguments but 3 were given\n```\n:::\n:::\n\n\nOn top of all of this, self also has access to other methods themselves. To show this, we'll bring back our print banana function and call it from within annihilate:\n\n::: {.cell outputId='ebb8e376-2e7b-4eda-ebce-3fea6271be73' execution_count=14}\n``` {.python .cell-code}\nc = 3 * 10**8\n\n\nclass Electron:\n\n    def __init__(self, charge=-1, mass=9.10938356e-31):\n        self.charge = charge\n        self.mass = mass\n\n    def annihilate(self, c):\n        self.print_banana()\n        return self.mass * c**2\n\n    def print_banana(self):\n        print(\"banana\")\n\n\nelectron = Electron()\nelectron.annihilate(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbanana\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n8.198445204e-14\n```\n:::\n:::\n\n\nNote even though print banana is defined after annihilate, we can still call annihilate on our instance of Electron. It can then run the method annihilate and even call `print_banana()`. How? Simple. When we do the `electron = Electron()` variable assignment, all our \"stuff\" for the class Electron gets instantiated. It already knows how `print_banana()` should work. That call to self.`print_banana()` simply looks it up, does what it needs to do, and doesn't cause a fuss.\n\nNice. Now that we can make classes, assignment them values we can access, and have methods we can use, we can now expand out from our particles and make atoms!\n\n## Expanding to Atoms\n\nAhhh, the atom. Simple yet complex. So what is an <a href=\"https://en.wikipedia.org/wiki/Atom\">atom</a>? Well it has a nucleus and electron clouds. Seems easy enough. Let's create one. Note we'll also be providing our elementary particle classes which we'll refactor as needed:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nclass Electron:\n\n    def __init__(self, charge=-1, mass=9.10938356e-31):\n        self.charge = charge\n        self.mass = mass\n\n\nclass Proton:\n\n    def __init__(self, charge=1, mass=1.67262158e-27):\n        self.charge = charge\n        self.mass = mass\n\n\nclass Neutron:\n\n    def __init__(self, charge=0, mass=1.67492721e-27):\n        self.charge = charge\n        self.mass = mass\n\n\nclass Atom:\n\n    def __init__(self, protons, neutrons, electrons):\n        self.protons = protons\n        self.neutrons = neutrons\n        self.electrons = electrons\n\n```\n:::\n\n\nOur Atom will start with only three simple instances: protons, neutrons, and electrons. Each will be a list of their repsective class types.\n\nTo start, let's make hydrogen:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nhydrogen = Atom([Proton()], [], [Electron()])\n```\n:::\n\n\n::: {.cell outputId='775ed526-246a-4084-8f64-ca7adb25f1e2' execution_count=17}\n``` {.python .cell-code}\nlen(hydrogen.protons), len(hydrogen.neutrons), len(hydrogen.electrons)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n(1, 0, 1)\n```\n:::\n:::\n\n\nCool. Now we can create any type of atom we want. For example, we could make Lithium, too.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nlithium = Atom([Proton(), Proton(), Proton()], [Neutron(),\n               Neutron(), Neutron()], [Electron(), Electron(), Electron()])\n```\n:::\n\n\n::: {.cell outputId='bb4718f3-507e-448f-ddff-267b2bd03b29' execution_count=19}\n``` {.python .cell-code}\nlen(lithium.protons), len(lithium.neutrons), len(lithium.electrons)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n(3, 3, 3)\n```\n:::\n:::\n\n\nThere we go. Now this hits upon something you'll see in OOP: <a href=\"https://en.wikipedia.org/wiki/Object_composition\">composition</a>. This only means that a class can be composed of other objects or classes. Here, we're using protons, neutrons, and electrons to make up our atom.\n\nHowever, this looks ugly as is. We have to manually add our class instances in the Atom declaration. We should just be able to pass a number and then the class takes care of this for us. Let's do that:\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nclass Atom:\n\n    def __init__(self, protons: int, neutrons: int, electrons: int):\n        self.protons = [Proton() for _ in range(protons)]\n        self.neutrons = [Neutron() for _ in range(neutrons)]\n        self.electrons = [Electron() for _ in range(electrons)]\n\n```\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nhydrogen = Atom(1, 0, 1)\n```\n:::\n\n\n::: {.cell outputId='b48a8853-a2f4-43cb-bdfb-d50e25d02566' execution_count=22}\n``` {.python .cell-code}\n# same results but easier.\nlen(hydrogen.protons), len(hydrogen.neutrons), len(hydrogen.electrons)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n(1, 0, 1)\n```\n:::\n:::\n\n\nMuch better. We cut down on what we have to pass to our class instance to start it.\n\nAfter these last two examples though, you may wonder if and how we can simply make these element variables into classes themselves...didn't you? Well, luckily that moves us right into a fundemential concept in OOP: <a href=\"https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)\">inhertence</a>.\n\n## Inheritence: The Gold of the OOP World\n\nInheritence is a fundemential concept of OOP. As a tagline, inheritence can be said to be the following: build a base from another class and then build on top of it.\n\nWhat do we mean by that? Let's start with an example:\n\nWe want to be able to make element classes. However, elements share a lot with atoms...like a lot. An element is just a specific arragement of protons, neutrons, and electrons. Really the only thing an element has is a name, but to put a strict definition on an <a href=\"https://en.wikipedia.org/wiki/Chemical_element\">element</a> it's name depends on the number of protons it has.\n\nSo to start this journey, we'll write down an element class, inherit from the atom, and then add stuff and explain along the way:\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nclass Element(Atom):\n\n    def __init__(self, name, protons, neutrons, electrons):\n        super().__init__(protons, neutrons, electrons)\n        self.name = name\n\n```\n:::\n\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nelement = Element(\"Hydrogen\", 1, 0, 1)\n```\n:::\n\n\n::: {.cell outputId='7f1b0777-6e2a-4bf3-98cd-0a3add2b12ab' execution_count=25}\n``` {.python .cell-code}\nelement.name, len(element.protons), len(\n    element.neutrons), len(element.electrons)\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n('Hydrogen', 1, 0, 1)\n```\n:::\n:::\n\n\nOn its face, Element looks a lot like Atom. The only difference between these two are the name attribute we gave and these two new additions:\n\n`class Element(Atom):`\n\n`super().__init__(protons, neutrons, electrons)`\n\nWhat is Atom doing in parenthesis there? That tells Element you want to inherit the Atom class. Think of Atom as the parent of Element. Anything that an Atom can do an Element can, too. However, the inverse is not true. Element will and can do more than an Atom.\n\nIn most intro OOP texts you'll usually see an example of a Dog and Cat class inheriting from an Animal class. Sometimes classes that inherit others can be seen as a more narrow version of the parent class. Other times though, the inherited class could extend and expand upon the parent class, but all the class that inherit from it share a common feature or kind of data.\n\nThe main takeaway is that by inheriting Atom, we get all of it's funtionality and attirbutes.\n\nWhich brings us to this line: `super().__init__(protons, neutrons, electrons)`\n\nWhat's going on there? To put it briefly, this whole super init thing is the same as doing `Atom(protons, neutrons, electrons)`. Since we know Element inherits all of Atom's attributes, we want a single line that declares and set those all at once. We don't want to have to repeat our self.blahblah = blah stuff. That's the point of why we inherited from Atom. We can take it's attributes, quickly assign them, and move on.\n\n## Extending our World With Methods\n\nNext up, we'll spice up our element class with a few tricks. Just having an elemnet static with no change in electrons is boring and not really chemistry. Let's first find a way to <a href=\"https://en.wikipedia.org/wiki/Ionization\">ionize</a> our electrons and change their charge. To do so, we'll have to be able to remove electrons from our element and in doing so change the charge. This means we need a way do stuff to our class.\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# mapping to get name from proton count\natomic_number2name = {\n    1: \"Hydrogen\",\n    2: \"Helium\",\n    3: \"Lithium\",\n    4: \"Beryllium\",\n    5: \"Boron\",\n    6: \"Carbon\",\n    7: \"Nitrogen\",\n    8: \"Oxygen\",\n    9: \"Fluorine\",\n    10: \"Neon\",\n    11: \"Sodium\",\n    12: \"Magnesium\",\n    13: \"Aluminium\",\n    14: \"Silicon\",\n    15: \"Phosphorus\",\n    16: \"Sulphur\",\n    17: \"Chlorine\",\n    18: \"Argon\",\n    19: \"Potassium\",\n    20: \"Calcium\",\n    21: \"Scandium\",\n    22: \"Titanium\",\n    23: \"Vanadium\",\n    24: \"Chromium\",\n    25: \"Manganese\",\n    26: \"Iron\",\n    27: \"Cobalt\",\n    28: \"Nickel\",\n    29: \"Copper\",\n    30: \"Zinc\",\n    31: \"Gallium\",\n    32: \"Germanium\",\n    33: \"Arsenic\",\n    34: \"Selenium\",\n    35: \"Bromine\",\n    36: \"Krypton\",\n    37: \"Rubidium\",\n    38: \"Strontium\",\n    39: \"Yttrium\",\n    40: \"Zirconium\",\n    41: \"Niobium\",\n    42: \"Molybdenum\",\n    43: \"Technetium\",\n    44: \"Ruthenium\",\n    45: \"Rhodium\",\n    46: \"Palladium\",\n    47: \"Silver\",\n    48: \"Cadmium\",\n    49: \"Indium\",\n    50: \"Tin\",\n    51: \"Antimony\",\n    52: \"Tellurium\",\n    53: \"Iodine\",\n    54: \"Xenon\",\n    55: \"Caesium\",\n    56: \"Barium\",\n    57: \"Lanthanum\",\n    58: \"Cerium\",\n    59: \"Praseodymium\",\n    60: \"Neodymium\",\n    61: \"Promethium\",\n    62: \"Samarium\",\n    63: \"Europium\",\n    64: \"Gadolinium\",\n    65: \"Terbium\",\n    66: \"Dysprosium\",\n    67: \"Holmium\",\n    68: \"Erbium\",\n    69: \"Thuliumm\",\n    70: \"Ytterbium\",\n    71: \"Lutetium\",\n    72: \"Hafnium\",\n    73: \"Tantalum\",\n    74: \"Tungsten\",\n    75: \"Rhenium\",\n    76: \"Osmium\",\n    77: \"Iridium\",\n    78: \"Platinum\",\n    79: \"Gold\",\n    80: \"Mercury\",\n    81: \"Thallium\",\n    82: \"Lead\",\n    83: \"Bismuth\",\n    84: \"Polonium\",\n    85: \"Astatine\",\n    86: \"Radon\"\n}\n```\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nclass Element(Atom):\n\n    def __init__(self, protons, neutrons, electrons):\n\n        # add assertions to make sure we're not making invalid elements\n        if electrons < 0:\n            raise ValueError(\"Electrons must be greater than 0\")\n        if protons < 0:\n            raise ValueError(\"Protons must be greater than 0\")\n        if neutrons < 0:\n            raise ValueError(\"Protons must be greater than 0\")\n\n        super().__init__(protons, neutrons, electrons)\n        self.name = atomic_number2name[protons]\n        self.charge = protons - electrons\n\n    def ionize_remove(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be greater than zero\")\n\n        for electron in range(change):\n            self.electrons.pop()\n\n    def ionize_add(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be less than zero\")\n\n        for electron in range(change):\n            self.electrons.append(Electron())\n\n```\n:::\n\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nmy_element = Element(12, 14, 10)\n```\n:::\n\n\n::: {.cell outputId='31da3ee1-3429-4058-d2b7-70d8bee77254' execution_count=29}\n``` {.python .cell-code}\n# our mapping works!\nmy_element.name\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n'Magnesium'\n```\n:::\n:::\n\n\n::: {.cell outputId='43cb60c9-90fd-425f-bd5f-d83b1fc8d5fa' execution_count=30}\n``` {.python .cell-code}\nlen(my_element.electrons)\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n10\n```\n:::\n:::\n\n\n::: {.cell outputId='d4dd38be-cc91-4633-ff5c-a2dbfdb75214' execution_count=31}\n``` {.python .cell-code}\nmy_element.ionize_remove(3)\nlen(my_element.electrons)\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n7\n```\n:::\n:::\n\n\n::: {.cell outputId='5d82ca4d-45a2-4ed8-960e-398b8824c67e' execution_count=32}\n``` {.python .cell-code}\nmy_element.ionize_add(10)\nlen(my_element.electrons)\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n17\n```\n:::\n:::\n\n\nAlright. We're on our way towards some good stuff here. We can create our element, ionize it (i.e. remove or add electrons), and we know what it's called.\n\nOne thing I have been noticing throughout this though is the annoyance of having to call our len function everytime we want to see the number of electrons, protons, or neutrons. Wouldn't a quick method be good to just grab these? Or what about another attribute we call num_electrons and just calculate the number of electrons based on our list len? Both of these strategies are valid, however, making a new attribute requires adding to our ionization code, while creating a new method adds to our methods, but no changes to our current functions.\n\nThese are tradeoffs you'll have to decide on while writing code all the time with OOP and in general. Sometimes there is a strict right or wrong answer. Other times, not so much.\n\nSince I'm dictator of this post, let's implement it my way:\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nclass Element(Atom):\n\n    def __init__(self, protons, neutrons, electrons):\n\n        # add assertions to make sure we're not making invalid elements\n        if electrons < 0:\n            raise ValueError(\"Electrons must be greater than 0\")\n        if protons < 0:\n            raise ValueError(\"Protons must be greater than 0\")\n        if neutrons < 0:\n            raise ValueError(\"Protons must be greater than 0\")\n\n        super().__init__(protons, neutrons, electrons)\n        self.name = atomic_number2name[protons]\n        self.charge = protons - electrons\n\n    def electron_count(self):\n        return len(self.electrons)\n\n    def proton_count(self):\n        return len(self.protons)\n\n    def neutron_count(self):\n        return len(self.neutrons)\n\n    def ionize_remove(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be greater than zero\")\n\n        for electron in range(change):\n            self.electrons.pop()\n\n    def ionize_add(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be less than zero\")\n\n        for electron in range(change):\n            self.electrons.append(Electron())\n\n```\n:::\n\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\nmy_element = Element(12, 14, 10)\n```\n:::\n\n\n::: {.cell outputId='d7452126-a2dc-4df1-f0c8-0da28e89d86a' execution_count=35}\n``` {.python .cell-code}\n# it works!\nprint(my_element.electron_count())\nmy_element.ionize_remove(3)\nprint(my_element.electron_count())\nmy_element.ionize_add(10)\nprint(my_element.electron_count())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10\n7\n17\n```\n:::\n:::\n\n\nGreat! Now we have a way to access our attirbutes without using the an external function like len. If you haven't been working with python or come from another programming language, this accessing of attributes i.e. using methods to get attributes might seem normal. In other languages like Java, you can have private attributes. These cannot be accessed like we can in python with the . operator. They're private so they cannot be changed unless we create a specific method to do so.\n\nBut this is python. No private stuff here.\n\nLet's continue our refactor. Next, we'll add a few new features:\n\n- Restricting anyone from removing more electrons than an Element has\n- Create a method to remove protons and neutrons\n- Keep the atomic number as an attribute and use that to map to name.\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\nclass Element(Atom):\n\n    def __init__(self, protons, neutrons, electrons):\n\n        # add assertions to make sure we're not making invalid elements\n        if electrons < 0:\n            raise ValueError(\"Electrons must be greater than 0\")\n        if protons < 0:\n            raise ValueError(\"Protons must be greater than 0\")\n        if neutrons < 0:\n            raise ValueError(\"Protons must be greater than 0\")\n\n        super().__init__(protons, neutrons, electrons)\n        self.charge = protons - electrons\n        self.atomic_number = self.proton_count()\n\n    def electron_count(self):\n        return len(self.electrons)\n\n    def proton_count(self):\n        return len(self.protons)\n\n    def neutron_count(self):\n        return len(self.neutrons)\n\n    def get_atomic_number(self):\n        return self.atomic_number\n\n    def get_name(self):\n        return atomic_number2name[self.atomic_number]\n\n    def ionize_remove(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be greater than zero\")\n\n        for electron in range(change):\n            self.electrons.pop()\n\n    def ionize_add(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be less than zero\")\n\n        for electron in range(change):\n            self.electrons.append(Electron())\n\n    def remove_proton(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be greater than zero\")\n        if self.proton_count() <= change:\n            raise ValueError(\"Change must be greater than protons\")\n\n        for proton in range(change):\n            self.protons.pop()\n            self.atomic_number -= 1\n\n    def add_proton(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be greater than zero\")\n\n        for proton in range(change):\n            self.protons.append(Proton())\n            self.atomic_number += 1\n\n```\n:::\n\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\nmy_element = Element(23, 23, 24)\n```\n:::\n\n\n::: {.cell outputId='0ef0bd04-c344-4a1c-e797-4424d4c280f4' execution_count=38}\n``` {.python .cell-code}\nmy_element.get_name(), my_element.get_atomic_number()\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\n('Vanadium', 23)\n```\n:::\n:::\n\n\n::: {.cell outputId='083e0268-b86a-4d60-d1cf-50306c3d4c92' execution_count=39}\n``` {.python .cell-code}\nmy_element.remove_proton(2)\nmy_element.get_name(), my_element.get_atomic_number()\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n('Scandium', 21)\n```\n:::\n:::\n\n\nWe can do alchemy now. Create an element and change it at will. We can even turn iron to gold:\n\n::: {.cell outputId='f8f62340-74ef-49d2-83c8-e660f5f3a793' execution_count=40}\n``` {.python .cell-code}\nmaterial = Element(82, 82, 82)\nprint(\"Start:\", material.get_name())\n\nmaterial.remove_proton(3)\nprint(\"End:\", material.get_name())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStart: Lead\nEnd: Gold\n```\n:::\n:::\n\n\nAbit ionized Gold (remember that means there are a different number of electrons than protons), but Gold still.\n\nAnother refactor we can do is something we've been dealing with this whole time that seems annoying: having to enter the same number if elements are \"normal\" i.e. same number of protons, electrons, and neutrons.\n\nWouldn't it be nice to do `Element(82)` to make lead instead of `Element(82, 82, 82)`. Other programming languages use <a href=\"https://en.wikipedia.org/wiki/Function_overloading\">overloading</a>. This means you can create a class instance in many ways. Say you want your class user to be able to create a class instace with a str or int. What do you do? Or in our case, we want people to be able to create an element with 1 or 3 args? Python may not be as elegant, but you can do it:\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\nclass Element(Atom):\n\n    def __init__(self, *args):\n\n        if len(args) == 1:\n            protons, neutrons, electrons = [args[0]] * 3\n        elif len(args) == 3:\n            protons, neutrons, electrons = args\n        else:\n            raise ValueError(\"Invalid number of arguments.\")\n\n        # add assertions to make sure we're not making invalid elements\n        if electrons < 0:\n            raise ValueError(\"Electrons must be greater than 0\")\n        if protons < 0:\n            raise ValueError(\"Protons must be greater than 0\")\n        if neutrons < 0:\n            raise ValueError(\"Protons must be greater than 0\")\n\n        super().__init__(protons, neutrons, electrons)\n        self.charge = protons - electrons\n        self.atomic_number = self.proton_count()\n\n    def electron_count(self):\n        return len(self.electrons)\n\n    def proton_count(self):\n        return len(self.protons)\n\n    def neutron_count(self):\n        return len(self.neutrons)\n\n    def get_atomic_number(self):\n        return self.atomic_number\n\n    def get_name(self):\n        return atomic_number2name[self.atomic_number]\n\n    def ionize_remove(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be greater than zero\")\n\n        for electron in range(change):\n            self.electrons.pop()\n\n    def ionize_add(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be less than zero\")\n\n        for electron in range(change):\n            self.electrons.append(Electron())\n\n    def remove_proton(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be greater than zero\")\n        if self.proton_count() <= change:\n            raise ValueError(\"Change must be greater than protons\")\n\n        for proton in range(change):\n            self.protons.pop()\n            self.atomic_number -= 1\n\n    def add_proton(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be greater than zero\")\n\n        for proton in range(change):\n            self.protons.append(Proton())\n            self.atomic_number += 1\n\n```\n:::\n\n\n::: {.cell outputId='480ac2ed-9c88-4151-e305-24ca34cafed5' execution_count=42}\n``` {.python .cell-code}\nmaterial = Element(82)\nprint(\"Start:\", material.get_name())\n\nmaterial.remove_proton(3)\nprint(\"End:\", material.get_name())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStart: Lead\nEnd: Gold\n```\n:::\n:::\n\n\nLooks like it works. Our only changes where here:\n\n```\ndef __init__(self, *args):\n\n    if len(args) == 1:\n      protons, neutrons, electrons = [args[0]] * 3\n    elif len(args) == 3:\n      protons, neutrons, electrons = args\n    else:\n      raise ValueError(\"Invalid\")\n```\n\n`*args`, if you haven't used it, let's us define an arbitrary amount of arguments in our class instance. We could pass as many or as little as we want, and our `__init__` function interprets them as a tuple. Simple, plain, old tuple. See:\n\n::: {.cell outputId='c56bbdbd-678c-42c1-ed46-8bdf911d8fb5' execution_count=43}\n``` {.python .cell-code}\ndef func(*args):\n    print(type(args))\n\n\nfunc(1, 5, 2, 5, 2, 5, 54)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'tuple'>\n```\n:::\n:::\n\n\nWe definitely don't want args to be mutable or change so we have them as a tuple. Makes sense. However, to the main point. Our change to ```__init__``` allows us to sent 1 or 3 args but no more and no less. Anything else and we get a value error:\n\n::: {.cell outputId='0ee95a62-4ad4-4f19-f0c8-a8f5cce338d9' execution_count=44}\n``` {.python .cell-code}\nElement(82, 82)\n```\n\n::: {.cell-output .cell-output-error}\n```\nValueError: Invalid number of arguments.\n```\n:::\n:::\n\n\n::: {.cell outputId='09b5c51f-5003-4a65-8da5-caa589d55f62' execution_count=45}\n``` {.python .cell-code}\nElement()\n```\n\n::: {.cell-output .cell-output-error}\n```\nValueError: Invalid number of arguments.\n```\n:::\n:::\n\n\n::: {.cell outputId='96f3803c-de77-4816-f028-f88eeeaf84f8' execution_count=46}\n``` {.python .cell-code}\nElement(82, 82, 82, 83)\n```\n\n::: {.cell-output .cell-output-error}\n```\nValueError: Invalid number of arguments.\n```\n:::\n:::\n\n\nNotice though that we don't have an error around the class taking arguments, but rather, an error about the number of arguments we passed.\n\nWe could do the same thing with our methods, however, we don't have a real use case that I can see yet.\n\nAlright. We have some basic chemistry going on. We can have elements and do stuff. Let's do a few operations on what we've done and call it a day for now. (Maybe have this be a part one of a series to make this ever expanding?).\n\nHowever, I wanted to do one last refactor. I want to move all the stuff we did in Element to Atom. Why? Because ionization and proton removal can be tasks of both the Element or Atom class. Why put them in Atom? Could be a design choice, however, I say that if an Atom can do it, why not leave it there and simplify our Element class in case we want to add to it. On top of this, we'll add an add or remove neutron method to Atom as well. This created an <a href=\"https://en.wikipedia.org/wiki/Isotope\">isotope</a>:\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\nclass Atom:\n\n    def __init__(self, protons: int, neutrons: int, electrons: int):\n        self.protons = [Proton() for _ in range(protons)]\n        self.neutrons = [Neutron() for _ in range(neutrons)]\n        self.electrons = [Electron() for _ in range(electrons)]\n\n    def electron_count(self):\n        return len(self.electrons)\n\n    def proton_count(self):\n        return len(self.protons)\n\n    def neutron_count(self):\n        return len(self.neutrons)\n\n    def get_charge(self):\n        return self.proton_count() - self.electron_count()\n\n    def get_mass(self):\n        return sum([proton.mass + electron.mass + neutron.mass\n                    for proton, electron, neutron\n                    in zip(self.protons, self.electrons, self.neutrons)])\n\n    def ionize_remove(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be greater than zero\")\n\n        for electron in range(change):\n            self.electrons.pop()\n\n    def ionize_add(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be less than zero\")\n\n        for electron in range(change):\n            self.electrons.append(Electron())\n\n    def remove_proton(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be greater than zero\")\n        if self.proton_count() <= change:\n            raise ValueError(\"Change must be greater than protons\")\n\n        for proton in range(change):\n            self.protons.pop()\n            self.atomic_number -= 1\n\n    def add_proton(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be greater than zero\")\n\n        for proton in range(change):\n            self.protons.append(Proton())\n            self.atomic_number += 1\n\n    def add_neutron(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be greater than zero\")\n\n        for neutron in range(change):\n            self.neutrons.append(Neutron())\n\n    def remove_neutron(self, change):\n\n        if not isinstance(change, int):\n            raise ValueError(\"Change must be an integer\")\n        if change < 1:\n            raise ValueError(\"Change must be greater than zero\")\n\n        for neutron in range(change):\n            self.neutrons.pop()\n```\n:::\n\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\nclass Element(Atom):\n\n    def __init__(self, *args):\n\n        if len(args) == 1:\n            protons, neutrons, electrons = [args[0]] * 3\n        elif len(args) == 3:\n            protons, neutrons, electrons = args\n        else:\n            raise ValueError(\"Invalid number of arguments.\")\n\n        # add assertions to make sure we're not making invalid elements\n        if electrons < 0:\n            raise ValueError(\"Electrons must be greater than 0\")\n        if protons < 0:\n            raise ValueError(\"Protons must be greater than 0\")\n        if neutrons < 0:\n            raise ValueError(\"Protons must be greater than 0\")\n\n        super().__init__(protons, neutrons, electrons)\n        self.charge = protons - electrons\n        self.atomic_number = self.proton_count()\n\n    def get_atomic_number(self):\n        return self.atomic_number\n\n    def get_name(self):\n        return atomic_number2name[self.atomic_number]\n\n```\n:::\n\n\n::: {.cell outputId='a84fc8f9-c466-4f6d-d7f2-9fc64d9a9213' execution_count=49}\n``` {.python .cell-code}\nmaterial = Element(79)\nprint(material.get_mass())\nprint(material.get_charge())\n\nmaterial.ionize_remove(3)\nprint(material.get_mass())\nprint(material.get_charge())\nprint(material.get_name())\n\nmaterial.remove_proton(5)\nprint(material.get_mass())\nprint(material.get_charge())\nprint(material.get_name())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2.6452831854012394e-25\n0\n2.5448293935505594e-25\n3\nGold\n2.4778601989834395e-25\n-2\nTungsten\n```\n:::\n:::\n\n\nAnd there you have it. We have some basics for OOP using chemistry concepts. We can create and alter matter at will. We can turn lead into gold, create ions or isotopes, and generally control space and time....well maybe not that far.\n\nIn future posts, I might build this out but hopefully this helps someone, somewhere just a bit.\n\nFeedback always welcome.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}